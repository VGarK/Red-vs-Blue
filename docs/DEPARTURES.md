->I will use this file to explain the whole process of how I designed the code. As I was progressing with development, I could see different approaches, some of them would benefit the code and they would result in an impromevent to it. If that was the case, I was ready to change patterns.

->With that in mind, what I always followed was a way to make the given code flexible, easy to read, easy to maintain and easy to expand. The process was as follows:

1) At first I used the Command Pattern, a behavioural pattern. It can be used to manage algorithms, responsabilities and relationships between objects. With it, I was able to encapsulate a request as an object, that allowed me to parameterise clients with various requests. So the switch statement could be broken into different requests and the client would be able to choose the relevant phase to use. I had one problem with this approach: it forced me to make a lot of command classes (one of my goals was to make the code easy to read, not to generate a bunch of spaghetti-like code).

2) There were better options that allowed more flexibility to the code. Between them, the most appealing were the State Pattern, the Composition Pattern and the Strategy Pattern. Because I wanted a specific strategy to be applied for a particular task, I dropped the idea of Composition. And so, at first the State Pattern seemed more correct as it allowed runtime flexibility and allowed me to change the algorithm being used without changing its class (and it is, of course, also a behavioural design pattern). I was sure that after implementing it, the code would be more cleaner and easy to read. I created a Context, an Interface and the corresponding Classes (they appear in the code I submitted). Now the code looked cleaner thanks to my polymorphic behaviour, plus I could easily add states for different Phases (I could easily add, after SelectingNewLocation, a new Phase to the game and it would fit perfectly!). 

3) I found out I had a problem: I had multiple algorithms for specific phases of the game, and I wanted the application to be both clean and flexible (I wanted the machine to choose any of the phases at runtime). In the State Pattern, the Context contains state as an instance variable and there can be multiple tasks whose implementation can be dependent on the state. If I looked back, I could see that the Strategy Pattern was there, waiting for me. It was pecfect as in it, its strategy is passed as an argument to the method and Context object does not have any variable to store it. In addition, another reason for me to choose the Strategy Pattern was because the idea and the implementation of the State Pattern was similar to the Strategy one.

*The Strategy Pattern is explained in the PATTERN.md file.
